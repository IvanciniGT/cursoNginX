user                    nginx;   # Usuario con el que se crean los subprocesos . P ej. Workers
worker_processes        2;       # Numero de workers. Depende de las CPUs disponibles
error_log  /var/log/nginx/error.log warn;   # Ubicación fichero de log de errores . Con el nivel de severidad
pid        /var/run/nginx.pid;              # Ubicación fichero que contiene el PID del master de nginx

events {
    worker_connections  1024;              # Número de hilos /Conexiones simultaneas atendibles por UN worker
}

## Parte de la configuración que alude al protocolo http

http {
    include       /etc/nginx/mime.types;    # Tipos de archivos (asociados a extensiones) que nginx auto-reconoce
    default_type  application/octet-stream; # Si no encuentra un tipo de datos en el fichero anterior, pon este. BINARIOS
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
                # LISTADO DE VARIABLES EN NGINX: http://nginx.org/en/docs/varindex.html
                    # En este caso, al formato, le denominamos "main"... es un nombre con el que referirnos a él.

    access_log  /var/log/nginx/access.log  main;    # Ubicacion de un archivo donde se genere un log de accesos / Peticiones HTTP
    sendfile        on;                             # Cómo nginx lee los ficheros a la hora de mandarlos al cliente.
                                        # Con sendfile off => POR DEFECTO
                                                # Nginx lee los ficheros a un buffer en RAM y desde ese buffer se van mandando al cliente
                                        # Con sendfile on => NO ES POR DEFECTO
                                                # Nginx lee los ficheros y según va leyendo lo va mandando al cliente, sin cargarlo a un buffer propio en RAM
                                                    # ESTO VA GUAY EN LINUX. En otros SO..... bufffff
    #tcp_nopush     on;
    keepalive_timeout  65;              # Tiempo que se va a mantener abierta la conexión sin notificaciones del cliente
    #gzip  on;

    # Esto sería un VIRTUAL HOST
    server {
#        listen  IP:80;             # Abrir el puerto 80, y escuchar peticiones. 
                                    # Las que lleguen por ese puerto (del interfaz de red que configure opcionalmente) 
                                    # serán atendidas por este servidor( es decir, se le aplicarán estas reglas)
        listen  80;                 
        server_name  localhost;     # El DNS a través del que se pueden recibir las peticiones adicionalmente
        
        root /sitios/sitio1;
        
        error_page  404              /error.html;
        error_page  500 502 503 504  /error.html;

        location /videos {
            root   /datos;
            index  index.html index.htm;
        }
        # redirect server error pages to the static page /50x.html
        #
#        error_page   500 502 503 504  /50x.html;
#        location = /50x.html {
#            root   /usr/share/nginx/html;
#        }
        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }
}
